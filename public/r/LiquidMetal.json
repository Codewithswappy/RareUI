{
  "name": "LiquidMetal",
  "type": "registry:ui",
  "dependencies": [
    "react",
    "@types/react",
    "typescript"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "components/rareui/LiquidMetal.tsx",
      "content": "\"use client\";\r\n\r\nimport React, { useEffect, useRef, useState, useCallback } from \"react\";\r\n\r\n// Shader Source Code\r\nconst vertexShaderSource = `#version 300 es\r\nprecision mediump float;\r\n\r\nin vec2 a_position;\r\nout vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = .5 * (a_position + 1.);\r\n    gl_Position = vec4(a_position, 0.0, 1.0);\r\n}`;\r\n\r\nconst liquidFragSource = `#version 300 es\r\n# ifdef GL_ES\r\nprecision highp float;\r\n# else\r\nprecision mediump float;\r\n# endif\r\n\r\nin vec2 vUv;\r\nout vec4 fragColor;\r\n\r\nuniform sampler2D u_image_texture;\r\nuniform float u_time;\r\nuniform float u_ratio;\r\nuniform float u_img_ratio;\r\nuniform float u_patternScale;\r\nuniform float u_refraction;\r\nuniform float u_edge;\r\nuniform float u_patternBlur;\r\nuniform float u_liquid;\r\n\r\n#define PI 3.14159265358979323846\r\n\r\nvec3 mod289(vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\r\nvec2 mod289(vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\r\nvec3 permute(vec3 x) { return mod289(((x*34.)+1.)*x); }\r\nfloat snoise(vec2 v) {\r\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\r\n    vec2 i = floor(v + dot(v, C.yy));\r\n    vec2 x0 = v - i + dot(i, C.xx);\r\n    vec2 i1;\r\n    i1 = (x0.x > x0.y) ? vec2(1., 0.) : vec2(0., 1.);\r\n    vec4 x12 = x0.xyxy + C.xxzz;\r\n    x12.xy -= i1;\r\n    i = mod289(i);\r\n    vec3 p = permute(permute(i.y + vec3(0., i1.y, 1.)) + i.x + vec3(0., i1.x, 1.));\r\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.);\r\n    m = m*m;\r\n    m = m*m;\r\n    vec3 x = 2. * fract(p * C.www) - 1.;\r\n    vec3 h = abs(x) - 0.5;\r\n    vec3 ox = floor(x + 0.5);\r\n    vec3 a0 = x - ox;\r\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\r\n    vec3 g;\r\n    g.x = a0.x * x0.x + h.x * x0.y;\r\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\r\n    return 130. * dot(m, g);\r\n}\r\n\r\nvec2 get_img_uv() {\r\n    vec2 img_uv = vUv;\r\n    img_uv -= .5;\r\n    if (u_ratio > u_img_ratio) {\r\n        img_uv.x = img_uv.x * u_ratio / u_img_ratio;\r\n    } else {\r\n        img_uv.y = img_uv.y * u_img_ratio / u_ratio;\r\n    }\r\n    float scale_factor = 1.;\r\n    img_uv *= scale_factor;\r\n    img_uv += .5;\r\n    img_uv.y = 1. - img_uv.y;\r\n    return img_uv;\r\n}\r\n\r\nvec2 rotate(vec2 uv, float th) {\r\n    return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\r\n}\r\n\r\nfloat get_color_channel(float c1, float c2, float stripe_p, vec3 w, float extra_blur, float b) {\r\n    float ch = c2;\r\n    float border = 0.;\r\n    float blur = u_patternBlur + extra_blur;\r\n\r\n    ch = mix(ch, c1, smoothstep(.0, blur, stripe_p));\r\n\r\n    border = w[0];\r\n    ch = mix(ch, c2, smoothstep(border - blur, border + blur, stripe_p));\r\n\r\n    b = smoothstep(.2, .8, b);\r\n    border = w[0] + .4 * (1. - b) * w[1];\r\n    ch = mix(ch, c1, smoothstep(border - blur, border + blur, stripe_p));\r\n\r\n    border = w[0] + .5 * (1. - b) * w[1];\r\n    ch = mix(ch, c2, smoothstep(border - blur, border + blur, stripe_p));\r\n\r\n    border = w[0] + w[1];\r\n    ch = mix(ch, c1, smoothstep(border - blur, border + blur, stripe_p));\r\n\r\n    float gradient_t = (stripe_p - w[0] - w[1]) / w[2];\r\n    float gradient = mix(c1, c2, smoothstep(0., 1., gradient_t));\r\n    ch = mix(ch, gradient, smoothstep(border - blur, border + blur, stripe_p));\r\n\r\n    return ch;\r\n}\r\n\r\nfloat get_img_frame_alpha(vec2 uv, float img_frame_width) {\r\n    float img_frame_alpha = smoothstep(0., img_frame_width, uv.x) * smoothstep(1., 1. - img_frame_width, uv.x);\r\n    img_frame_alpha *= smoothstep(0., img_frame_width, uv.y) * smoothstep(1., 1. - img_frame_width, uv.y);\r\n    return img_frame_alpha;\r\n}\r\n\r\nvoid main() {\r\n    vec2 uv = vUv;\r\n    uv.y = 1. - uv.y;\r\n    uv.x *= u_ratio;\r\n\r\n    float diagonal = uv.x - uv.y;\r\n\r\n    float t = .001 * mod(u_time, 10000.0);\r\n\r\n    vec2 img_uv = get_img_uv();\r\n    vec4 img = texture(u_image_texture, img_uv);\r\n\r\n    vec3 color = vec3(0.);\r\n    float opacity = 1.;\r\n\r\n    vec3 color1 = vec3(.98, 0.98, 1.);\r\n    vec3 color2 = vec3(.1, .1, .1 + .1 * smoothstep(.7, 1.3, uv.x + uv.y));\r\n\r\n    float edge = img.r;\r\n\r\n    vec2 grad_uv = uv;\r\n    grad_uv -= .5;\r\n\r\n    float dist = length(grad_uv + vec2(0., .2 * diagonal));\r\n    grad_uv = rotate(grad_uv, (.25 - .2 * diagonal) * PI);\r\n\r\n    float bulge = pow(1.8 * dist, 1.2);\r\n    bulge = 1. - bulge;\r\n    bulge *= pow(uv.y, .3);\r\n\r\n    float cycle_width = u_patternScale;\r\n    float thin_strip_1_ratio = .12 / cycle_width * (1. - .4 * bulge);\r\n    float thin_strip_2_ratio = .07 / cycle_width * (1. + .4 * bulge);\r\n    float wide_strip_ratio = (1. - thin_strip_1_ratio - thin_strip_2_ratio);\r\n\r\n    float thin_strip_1_width = cycle_width * thin_strip_1_ratio;\r\n    float thin_strip_2_width = cycle_width * thin_strip_2_ratio;\r\n\r\n    opacity = 1. - smoothstep(.9 - .5 * u_edge, 1. - .5 * u_edge, edge);\r\n    opacity *= get_img_frame_alpha(img_uv, 0.01);\r\n\r\n    float noise = snoise(uv - t);\r\n    edge += (1. - edge) * u_liquid * noise;\r\n\r\n    float refr = 0.;\r\n    refr += (1. - bulge);\r\n    refr = clamp(refr, 0., 1.);\r\n\r\n    float dir = grad_uv.x;\r\n    dir += diagonal;\r\n    dir -= 2. * noise * diagonal * (smoothstep(0., 1., edge) * smoothstep(1., 0., edge));\r\n\r\n    bulge *= clamp(pow(uv.y, .1), .3, 1.);\r\n    dir *= (.1 + (1.1 - edge) * bulge);\r\n    dir *= smoothstep(1., .7, edge);\r\n    dir += .18 * (smoothstep(.1, .2, uv.y) * smoothstep(.4, .2, uv.y));\r\n\r\n    dir += .03 * (smoothstep(.1, .2, 1. - uv.y) * smoothstep(.4, .2, 1. - uv.y));\r\n    dir *= (.5 + .5 * pow(uv.y, 2.));\r\n    dir *= cycle_width;\r\n    dir -= t;\r\n\r\n    float refr_r = refr;\r\n    refr_r += .03 * bulge * noise;\r\n    float refr_b = 1.3 * refr;\r\n\r\n    refr_r += 5. * (smoothstep(-.1, .2, uv.y) * smoothstep(.5, .1, uv.y)) * (smoothstep(.4, .6, bulge) * smoothstep(1., .4, bulge));\r\n    refr_r -= diagonal;\r\n\r\n    refr_b += (smoothstep(0., .4, uv.y) * smoothstep(.8, .1, uv.y)) * (smoothstep(.4, .6, bulge) * smoothstep(.8, .4, bulge));\r\n    refr_b -= .2 * edge;\r\n\r\n    refr_r *= u_refraction;\r\n    refr_b *= u_refraction;\r\n\r\n    vec3 w = vec3(thin_strip_1_width, thin_strip_2_width, wide_strip_ratio);\r\n    w[1] -= .02 * smoothstep(.0, 1., edge + bulge);\r\n    float stripe_r = mod(dir + refr_r, 1.);\r\n    float r = get_color_channel(color1.r, color2.r, stripe_r, w, 0.02 + .03 * u_refraction * bulge, bulge);\r\n    float stripe_g = mod(dir, 1.);\r\n    float g = get_color_channel(color1.g, color2.g, stripe_g, w, 0.01 / (1. - diagonal), bulge);\r\n    float stripe_b = mod(dir - refr_b, 1.);\r\n    float b = get_color_channel(color1.b, color2.b, stripe_b, w, .01, bulge);\r\n\r\n    color = vec3(r, g, b);\r\n    color *= opacity;\r\n\r\n    fragColor = vec4(color, opacity);\r\n}\r\n`;\r\n\r\ninterface LiquidMetalProps {\r\n    imageSource?: string;\r\n    speed?: number;\r\n    dispersion?: number; // refraction\r\n    edge?: number;\r\n    patternBlur?: number;\r\n    liquify?: number;\r\n    patternScale?: number;\r\n    text?: string;\r\n}\r\n\r\nexport default function LiquidMetal({\r\n    imageSource,\r\n    speed = 0.3,\r\n    dispersion = 0.005, // Reduced from 0.015 for clearer edges\r\n    edge = 0.5,         // Increased from 0.4 for sharper definition\r\n    patternBlur = 0.005,\r\n    liquify = 0.08,    // Slightly adjusted\r\n    patternScale = 2,\r\n    text = \"RareUI\"\r\n}: LiquidMetalProps) {\r\n    const canvasRef = useRef<HTMLCanvasElement>(null);\r\n    const [gl, setGl] = useState<WebGL2RenderingContext | null>(null);\r\n    const [uniforms, setUniforms] = useState<any>({});\r\n    const [imageData, setImageData] = useState<ImageData | null>(null);\r\n    const [processing, setProcessing] = useState(false);\r\n    const totalAnimationTime = useRef(0);\r\n    const lastRenderTime = useRef(0);\r\n\r\n    const parseLogoImage = useCallback((file: File) => {\r\n        const canvas = document.createElement(\"canvas\");\r\n        const ctx = canvas.getContext(\"2d\");\r\n        return new Promise<ImageData>((resolve, reject) => {\r\n            if (!file || !ctx) {\r\n                reject(new Error(\"Invalid file or context\"));\r\n                return;\r\n            }\r\n            const img = new Image();\r\n            img.onload = function () {\r\n                if (file.type === \"image/svg+xml\") {\r\n                    img.width = 1000;\r\n                    img.height = 1000;\r\n                }\r\n                const MAX_SIZE = 1000;\r\n                const MIN_SIZE = 500;\r\n                let width = img.naturalWidth;\r\n                let height = img.naturalHeight;\r\n\r\n                // Logic from Framer component to resize\r\n                if (width > MAX_SIZE || height > MAX_SIZE || width < MIN_SIZE || height < MIN_SIZE) {\r\n                    if (width > height) {\r\n                        if (width > MAX_SIZE) {\r\n                            height = Math.round(height * MAX_SIZE / width);\r\n                            width = MAX_SIZE;\r\n                        } else if (width < MIN_SIZE) {\r\n                            height = Math.round(height * MIN_SIZE / width);\r\n                            width = MIN_SIZE;\r\n                        }\r\n                    } else {\r\n                        if (height > MAX_SIZE) {\r\n                            width = Math.round(width * MAX_SIZE / height);\r\n                            height = MAX_SIZE;\r\n                        } else if (height < MIN_SIZE) {\r\n                            width = Math.round(width * MIN_SIZE / height);\r\n                            height = MIN_SIZE;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                canvas.width = width;\r\n                canvas.height = height;\r\n\r\n                // Draw offscreen\r\n                const shapeCanvas = document.createElement(\"canvas\");\r\n                shapeCanvas.width = width;\r\n                shapeCanvas.height = height;\r\n                const shapeCtx = shapeCanvas.getContext(\"2d\")!;\r\n                shapeCtx.drawImage(img, 0, 0, width, height);\r\n\r\n                const shapeImageData = shapeCtx.getImageData(0, 0, width, height);\r\n                const data = shapeImageData.data;\r\n                const shapeMask = new Array(width * height).fill(false);\r\n\r\n                for (let y = 0; y < height; y++) {\r\n                    for (let x = 0; x < width; x++) {\r\n                        const idx4 = (y * width + x) * 4;\r\n                        const r = data[idx4];\r\n                        const g = data[idx4 + 1];\r\n                        const b = data[idx4 + 2];\r\n                        const a = data[idx4 + 3];\r\n                        // White or transparent is 'outside'\r\n                        if ((r === 255 && g === 255 && b === 255 && a === 255) || a === 0) {\r\n                            shapeMask[y * width + x] = false;\r\n                        } else {\r\n                            shapeMask[y * width + x] = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                function inside(x: number, y: number) {\r\n                    if (x < 0 || x >= width || y < 0 || y >= height) return false;\r\n                    return shapeMask[y * width + x];\r\n                }\r\n\r\n                const boundaryMask = new Array(width * height).fill(false);\r\n                for (let y = 0; y < height; y++) {\r\n                    for (let x = 0; x < width; x++) {\r\n                        const idx = y * width + x;\r\n                        if (!shapeMask[idx]) continue;\r\n                        let isBoundary = false;\r\n                        // 3x3 check\r\n                        for (let ny = y - 1; ny <= y + 1 && !isBoundary; ny++) {\r\n                            for (let nx = x - 1; nx <= x + 1 && !isBoundary; nx++) {\r\n                                if (!inside(nx, ny)) {\r\n                                    isBoundary = true;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (isBoundary) {\r\n                            boundaryMask[idx] = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Poisson solve\r\n                const u = new Float32Array(width * height).fill(0);\r\n                const newU = new Float32Array(width * height).fill(0);\r\n                const C = 0.01;\r\n                const ITERATIONS = 300;\r\n\r\n                function getU(x: number, y: number, arr: Float32Array) {\r\n                    if (x < 0 || x >= width || y < 0 || y >= height) return 0;\r\n                    if (!shapeMask[y * width + x]) return 0;\r\n                    return arr[y * width + x];\r\n                }\r\n\r\n                for (let iter = 0; iter < ITERATIONS; iter++) {\r\n                    for (let y = 0; y < height; y++) {\r\n                        for (let x = 0; x < width; x++) {\r\n                            const idx = y * width + x;\r\n                            if (!shapeMask[idx] || boundaryMask[idx]) {\r\n                                newU[idx] = 0;\r\n                                continue;\r\n                            }\r\n                            const sumN = getU(x + 1, y, u) + getU(x - 1, y, u) + getU(x, y + 1, u) + getU(x, y - 1, u);\r\n                            newU[idx] = (C + sumN) / 4;\r\n                        }\r\n                    }\r\n                    u.set(newU);\r\n                }\r\n\r\n                let maxVal = 0;\r\n                for (let i = 0; i < width * height; i++) {\r\n                    if (u[i] > maxVal) maxVal = u[i];\r\n                }\r\n\r\n                const alpha = 2;\r\n                const outImg = ctx!.createImageData(width, height);\r\n                for (let y = 0; y < height; y++) {\r\n                    for (let x = 0; x < width; x++) {\r\n                        const idx = y * width + x;\r\n                        const px = idx * 4;\r\n                        if (!shapeMask[idx]) {\r\n                            // Outside\r\n                            outImg.data[px] = 255;\r\n                            outImg.data[px + 1] = 255;\r\n                            outImg.data[px + 2] = 255;\r\n                            outImg.data[px + 3] = 255;\r\n                        } else {\r\n                            // Inside\r\n                            const raw = u[idx] / maxVal;\r\n                            const remapped = Math.pow(raw, alpha);\r\n                            const gray = 255 * (1 - remapped);\r\n                            outImg.data[px] = gray;\r\n                            outImg.data[px + 1] = gray;\r\n                            outImg.data[px + 2] = gray;\r\n                            outImg.data[px + 3] = 255;\r\n                        }\r\n                    }\r\n                }\r\n                resolve(outImg);\r\n            };\r\n            img.onerror = () => reject(new Error(\"Failed to load image\"));\r\n            img.src = URL.createObjectURL(file);\r\n        });\r\n    }, []);\r\n\r\n    // Create default logo (RareUI text)\r\n    const createDefaultSVGImage = useCallback(() => {\r\n        return new Promise<ImageData>((resolve, reject) => {\r\n            // Measure text width for responsive SVG size\r\n            const fontSize = 180;\r\n            const fontWeight = 900;\r\n            const fontFamily = \"'Arial Black', 'Verdana', sans-serif\";\r\n\r\n            // Create a temp canvas to measure text\r\n            const tempCanvas = document.createElement('canvas');\r\n            const tempCtx = tempCanvas.getContext('2d');\r\n            if (tempCtx) {\r\n                tempCtx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\r\n                // Add some padding for the stroke and liquid effect\r\n                const textMetrics = tempCtx.measureText(text);\r\n                const textWidth = Math.ceil(textMetrics.width);\r\n                const width = textWidth + 100; // Padding\r\n                const height = fontSize * 1.5;\r\n\r\n                const svgString = `\r\n                    <svg width=\"${width}\" height=\"${height}\" viewBox=\"0 0 ${width} ${height}\" xmlns=\"http://www.w3.org/2000/svg\">\r\n                        <style>\r\n                            text {\r\n                                font-family: ${fontFamily};\r\n                                font-weight: ${fontWeight};\r\n                                font-size: ${fontSize}px;\r\n                                fill: black;\r\n                                stroke: black;\r\n                                stroke-width: 5px; \r\n                                letter-spacing: -5px;\r\n                            }\r\n                        </style>\r\n                        <rect width=\"${width}\" height=\"${height}\" fill=\"white\" fill-opacity=\"0\"/> \r\n                        <text x=\"50%\" y=\"55%\" text-anchor=\"middle\" dominant-baseline=\"middle\">\r\n                            ${text}\r\n                        </text>\r\n                    </svg>\r\n                `;\r\n                const blob = new Blob([svgString], { type: \"image/svg+xml\" });\r\n                const file = new File([blob], \"default.svg\", { type: \"image/svg+xml\" });\r\n                parseLogoImage(file).then(resolve).catch(reject);\r\n            } else {\r\n                reject(new Error(\"Could not create canvas context for text measurement\"));\r\n            }\r\n        });\r\n    }, [text, parseLogoImage]);\r\n\r\n    // Initial load - generate or process\r\n    useEffect(() => {\r\n        if (!imageSource) {\r\n            setProcessing(true);\r\n            createDefaultSVGImage().then(data => {\r\n                setImageData(data);\r\n                setProcessing(false);\r\n            }).catch(e => {\r\n                console.error(e);\r\n                setProcessing(false);\r\n            });\r\n            return;\r\n        }\r\n\r\n        // If imageSource provided\r\n        setProcessing(true);\r\n        fetch(imageSource)\r\n            .then(res => res.blob())\r\n            .then(blob => {\r\n                const file = new File([blob], \"image\", { type: blob.type });\r\n                return parseLogoImage(file);\r\n            })\r\n            .then(data => {\r\n                setImageData(data);\r\n                setProcessing(false);\r\n            })\r\n            .catch(e => {\r\n                console.error(e);\r\n                setProcessing(false);\r\n            });\r\n    }, [imageSource, createDefaultSVGImage, parseLogoImage]);\r\n\r\n    // Init WebGL\r\n    useEffect(() => {\r\n        if (!canvasRef.current) return;\r\n        const canvas = canvasRef.current;\r\n        const context = canvas.getContext(\"webgl2\", {\r\n            antialias: true,\r\n            alpha: true,\r\n            premultipliedAlpha: false\r\n        });\r\n\r\n        if (!context) {\r\n            console.error(\"WebGL2 not supported\");\r\n            return;\r\n        }\r\n\r\n        const createShader = (gl: WebGL2RenderingContext, source: string, type: number) => {\r\n            const shader = gl.createShader(type);\r\n            if (!shader) return null;\r\n            gl.shaderSource(shader, source);\r\n            gl.compileShader(shader);\r\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n                console.error(\"Shader error:\", gl.getShaderInfoLog(shader));\r\n                gl.deleteShader(shader);\r\n                return null;\r\n            }\r\n            return shader;\r\n        };\r\n\r\n        const vShader = createShader(context, vertexShaderSource, context.VERTEX_SHADER);\r\n        const fShader = createShader(context, liquidFragSource, context.FRAGMENT_SHADER);\r\n\r\n        if (!vShader || !fShader) return;\r\n\r\n        const program = context.createProgram();\r\n        if (!program) return;\r\n        context.attachShader(program, vShader);\r\n        context.attachShader(program, fShader);\r\n        context.linkProgram(program);\r\n\r\n        if (!context.getProgramParameter(program, context.LINK_STATUS)) {\r\n            console.error(\"Link error:\", context.getProgramInfoLog(program));\r\n            return;\r\n        }\r\n\r\n        // Get uniforms\r\n        const uLocs: any = {};\r\n        const count = context.getProgramParameter(program, context.ACTIVE_UNIFORMS);\r\n        for (let i = 0; i < count; i++) {\r\n            const info = context.getActiveUniform(program, i);\r\n            if (info) {\r\n                uLocs[info.name] = context.getUniformLocation(program, info.name);\r\n            }\r\n        }\r\n\r\n        const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);\r\n        const vBuffer = context.createBuffer();\r\n        context.bindBuffer(context.ARRAY_BUFFER, vBuffer);\r\n        context.bufferData(context.ARRAY_BUFFER, vertices, context.STATIC_DRAW);\r\n\r\n        context.useProgram(program);\r\n        const posLoc = context.getAttribLocation(program, \"a_position\");\r\n        context.enableVertexAttribArray(posLoc);\r\n        context.bindBuffer(context.ARRAY_BUFFER, vBuffer);\r\n        context.vertexAttribPointer(posLoc, 2, context.FLOAT, false, 0, 0);\r\n\r\n        context.enable(context.BLEND);\r\n        context.blendFunc(context.SRC_ALPHA, context.ONE_MINUS_SRC_ALPHA);\r\n\r\n        setGl(context);\r\n        setUniforms(uLocs);\r\n\r\n        return () => {\r\n            // cleanup\r\n            context.deleteProgram(program);\r\n            context.deleteShader(vShader);\r\n            context.deleteShader(fShader);\r\n            context.deleteBuffer(vBuffer);\r\n        };\r\n    }, []);\r\n\r\n    // Update uniforms\r\n    useEffect(() => {\r\n        if (!gl || !uniforms) return;\r\n        gl.useProgram(gl.getParameter(gl.CURRENT_PROGRAM));\r\n        if (uniforms.u_patternScale) gl.uniform1f(uniforms.u_patternScale, patternScale);\r\n        if (uniforms.u_refraction) gl.uniform1f(uniforms.u_refraction, dispersion);\r\n        if (uniforms.u_edge) gl.uniform1f(uniforms.u_edge, edge);\r\n        if (uniforms.u_patternBlur) gl.uniform1f(uniforms.u_patternBlur, patternBlur);\r\n        if (uniforms.u_liquid) gl.uniform1f(uniforms.u_liquid, liquify);\r\n    }, [gl, uniforms, patternScale, dispersion, edge, patternBlur, liquify]);\r\n\r\n    // Handle resize and texture\r\n    useEffect(() => {\r\n        if (!gl || !uniforms || !canvasRef.current || !imageData) return;\r\n\r\n        const canvas = canvasRef.current;\r\n        const imgRatio = imageData.width / imageData.height;\r\n        const rect = canvas.getBoundingClientRect();\r\n\r\n        // Fix for retina\r\n        const dpr = window.devicePixelRatio || 1;\r\n        const width = rect.width * dpr;\r\n        const height = rect.height * dpr;\r\n\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        gl.viewport(0, 0, width, height);\r\n\r\n        gl.uniform1f(uniforms.u_ratio, width / height);\r\n        gl.uniform1f(uniforms.u_img_ratio, imgRatio);\r\n\r\n        const texture = gl.createTexture();\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, imageData.width, imageData.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData.data);\r\n        gl.uniform1i(uniforms.u_image_texture, 0);\r\n\r\n        return () => {\r\n            gl.deleteTexture(texture);\r\n        };\r\n    }, [gl, uniforms, imageData]);\r\n\r\n    // Animation loop\r\n    useEffect(() => {\r\n        if (!gl || !uniforms || !imageData) return;\r\n\r\n        let rafId: number;\r\n        const animate = (time: number) => {\r\n            const dt = time - lastRenderTime.current;\r\n            lastRenderTime.current = time;\r\n            totalAnimationTime.current += dt * speed;\r\n\r\n            // Keep precision\r\n            const normTime = totalAnimationTime.current % 10000;\r\n            gl.uniform1f(uniforms.u_time, normTime);\r\n\r\n            gl.clearColor(0, 0, 0, 0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n\r\n            rafId = requestAnimationFrame(animate);\r\n        };\r\n\r\n        lastRenderTime.current = performance.now();\r\n        rafId = requestAnimationFrame(animate);\r\n\r\n        return () => cancelAnimationFrame(rafId);\r\n    }, [gl, uniforms, imageData, speed]);\r\n\r\n    return (\r\n        <div className=\"w-full h-full relative flex items-center justify-center\">\r\n\r\n            <canvas\r\n                ref={canvasRef}\r\n                className=\"w-full h-full object-contain\"\r\n            />\r\n        </div>\r\n    );\r\n}\r\n",
      "type": "registry:ui",
      "target": "components/rareui/LiquidMetal.tsx"
    }
  ]
}