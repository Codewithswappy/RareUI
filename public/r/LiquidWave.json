{
  "name": "LiquidWave",
  "type": "registry:ui",
  "dependencies": [
    "react",
    "three",
    "@types/react",
    "typescript"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "components/rareui/interactive-background/LiquidWave.tsx",
      "content": "\"use client\";\r\n\r\nimport React, { useEffect, useRef } from \"react\";\r\nimport * as THREE from \"three\";\r\n\r\ninterface LiquidWaveProps {\r\n  color1?: string;\r\n  color2?: string;\r\n  color3?: string;\r\n  mouseForce?: number;\r\n  cursorSize?: number;\r\n  isViscous?: boolean;\r\n  viscous?: number;\r\n  iterationsViscous?: number;\r\n  iterationsPoisson?: number;\r\n  dt?: number;\r\n  BFECC?: boolean;\r\n  resolution?: number;\r\n  isBounce?: boolean;\r\n  autoDemo?: boolean;\r\n  autoSpeed?: number;\r\n  autoIntensity?: number;\r\n  takeoverDuration?: number;\r\n  autoResumeDelay?: number;\r\n  autoRampDuration?: number;\r\n  style?: React.CSSProperties;\r\n  className?: string;\r\n}\r\n\r\nexport default function LiquidWave({\r\n  color1 = \"orange\", \r\n  color2 = \"orange\",\r\n  color3 = \"orange\",\r\n  mouseForce = 20,\r\n  cursorSize = 100,\r\n  isViscous = false,\r\n  viscous = 30,\r\n  iterationsViscous = 32,\r\n  iterationsPoisson = 32,\r\n  dt = 0.014,\r\n  BFECC = true,\r\n  resolution = 0.5,\r\n  isBounce = false,\r\n  autoDemo = true,\r\n  autoSpeed = 0.5,\r\n  autoIntensity = 2.2,\r\n  takeoverDuration = 0.25,\r\n  autoResumeDelay = 3000,\r\n  autoRampDuration = 0.6,\r\n  style,\r\n  className,\r\n}: LiquidWaveProps) {\r\n  const mountRef = useRef<HTMLDivElement>(null);\r\n  const webglRef = useRef<any>(null);\r\n  const resizeObserverRef = useRef<ResizeObserver | null>(null);\r\n  const rafRef = useRef<number | null>(null);\r\n  const intersectionObserverRef = useRef<IntersectionObserver | null>(null);\r\n  const isVisibleRef = useRef<boolean>(true);\r\n  const resizeRafRef = useRef<number | null>(null);\r\n\r\n  useEffect(() => {\r\n    if (!mountRef.current) return;\r\n\r\n    // --- 1. Global / Common Classes ---\r\n    // We recreate the classes inside useEffect or outside to avoid global state issues in React HMR/strict mode\r\n    // Ideally, these should be separate, but for a port, keeping them scoped or module-level is fine.\r\n    // Given the complexity, I'll instantiate helpers inside a closure or keep them module-level \r\n    // IF we are sure only one instance corresponds to one canvas. \r\n    // The original code used a singleton `Common` and `Mouse`. \r\n    // We should make them instance-specific to allow multiple LiquidWaves on one page.\r\n\r\n    class CommonClass {\r\n      width = 0;\r\n      height = 0;\r\n      aspect = 1;\r\n      pixelRatio = 1;\r\n      container: HTMLElement | null = null;\r\n      renderer: THREE.WebGLRenderer | null = null;\r\n      clock: THREE.Clock | null = null;\r\n      delta = 0;\r\n      time = 0;\r\n\r\n      init(container: HTMLElement) {\r\n        this.container = container;\r\n        this.pixelRatio = Math.min(window.devicePixelRatio || 1, 2);\r\n        this.resize();\r\n        this.renderer = new THREE.WebGLRenderer({\r\n          antialias: true,\r\n          alpha: true,\r\n        });\r\n        this.renderer.autoClear = false;\r\n        this.renderer.setClearColor(new THREE.Color(0), 0);\r\n        this.renderer.setPixelRatio(this.pixelRatio);\r\n        this.renderer.setSize(this.width, this.height);\r\n        this.renderer.domElement.style.width = \"100%\";\r\n        this.renderer.domElement.style.height = \"100%\";\r\n        this.renderer.domElement.style.display = \"block\";\r\n        this.clock = new THREE.Clock();\r\n        this.clock.start();\r\n      }\r\n\r\n      resize() {\r\n        if (!this.container) return;\r\n        const rect = this.container.getBoundingClientRect();\r\n        this.width = Math.max(1, Math.floor(rect.width));\r\n        this.height = Math.max(1, Math.floor(rect.height));\r\n        this.aspect = this.width / this.height;\r\n        if (this.renderer)\r\n          this.renderer.setSize(this.width, this.height, false);\r\n      }\r\n\r\n      update() {\r\n        if (!this.clock) return;\r\n        this.delta = this.clock.getDelta();\r\n        this.time += this.delta;\r\n      }\r\n      \r\n      dispose() {\r\n          if (this.renderer) {\r\n              this.renderer.dispose();\r\n              this.renderer = null;\r\n          }\r\n      }\r\n    }\r\n\r\n    class MouseClass {\r\n      container: HTMLElement | null = null;\r\n      mouseMoved = false;\r\n      coords = new THREE.Vector2();\r\n      coords_old = new THREE.Vector2();\r\n      diff = new THREE.Vector2();\r\n      timer: any = null;\r\n      isHoverInside = false;\r\n      hasUserControl = false;\r\n      isAutoActive = false;\r\n      autoIntensity = 2;\r\n      takeoverActive = false;\r\n      takeoverStartTime = 0;\r\n      takeoverDuration = 0.25;\r\n      takeoverFrom = new THREE.Vector2();\r\n      takeoverTo = new THREE.Vector2();\r\n      onInteract: (() => void) | null = null;\r\n\r\n      init(container: HTMLElement) {\r\n        this.container = container;\r\n        container.addEventListener(\"mousemove\", this._onMouseMove, false);\r\n        container.addEventListener(\"touchstart\", this._onTouchStart, false);\r\n        container.addEventListener(\"touchmove\", this._onTouchMove, false);\r\n        container.addEventListener(\"mouseenter\", this._onMouseEnter, false);\r\n        container.addEventListener(\"mouseleave\", this._onMouseLeave, false);\r\n        container.addEventListener(\"touchend\", this._onTouchEnd, false);\r\n      }\r\n\r\n      dispose() {\r\n        if (!this.container) return;\r\n        this.container.removeEventListener(\"mousemove\", this._onMouseMove, false);\r\n        this.container.removeEventListener(\"touchstart\", this._onTouchStart, false);\r\n        this.container.removeEventListener(\"touchmove\", this._onTouchMove, false);\r\n        this.container.removeEventListener(\"mouseenter\", this._onMouseEnter, false);\r\n        this.container.removeEventListener(\"mouseleave\", this._onMouseLeave, false);\r\n        this.container.removeEventListener(\"touchend\", this._onTouchEnd, false);\r\n      }\r\n\r\n      setCoords(x: number, y: number) {\r\n        if (!this.container) return;\r\n        if (this.timer) clearTimeout(this.timer);\r\n        const rect = this.container.getBoundingClientRect();\r\n        const nx = (x - rect.left) / rect.width;\r\n        const ny = (y - rect.top) / rect.height;\r\n        this.coords.set(nx * 2 - 1, -(ny * 2 - 1));\r\n        this.mouseMoved = true;\r\n        this.timer = setTimeout(() => {\r\n          this.mouseMoved = false;\r\n        }, 100);\r\n      }\r\n\r\n      setNormalized(nx: number, ny: number) {\r\n        this.coords.set(nx, ny);\r\n        this.mouseMoved = true;\r\n      }\r\n\r\n      _onMouseMove = (event: MouseEvent) => {\r\n        if (this.onInteract) this.onInteract();\r\n        if (\r\n          this.isAutoActive &&\r\n          !this.hasUserControl &&\r\n          !this.takeoverActive &&\r\n          this.container\r\n        ) {\r\n          const rect = this.container.getBoundingClientRect();\r\n          const nx = (event.clientX - rect.left) / rect.width;\r\n          const ny = (event.clientY - rect.top) / rect.height;\r\n          this.takeoverFrom.copy(this.coords);\r\n          this.takeoverTo.set(nx * 2 - 1, -(ny * 2 - 1));\r\n          this.takeoverStartTime = performance.now();\r\n          this.takeoverActive = true;\r\n          this.hasUserControl = true;\r\n          this.isAutoActive = false;\r\n          return;\r\n        }\r\n        this.setCoords(event.clientX, event.clientY);\r\n        this.hasUserControl = true;\r\n      };\r\n\r\n      _onTouchStart = (event: TouchEvent) => {\r\n        if (event.touches.length === 1) {\r\n          const t = event.touches[0];\r\n          if (this.onInteract) this.onInteract();\r\n          this.setCoords(t.pageX, t.pageY);\r\n          this.hasUserControl = true;\r\n        }\r\n      };\r\n\r\n      _onTouchMove = (event: TouchEvent) => {\r\n        if (event.touches.length === 1) {\r\n          const t = event.touches[0];\r\n          if (this.onInteract) this.onInteract();\r\n          this.setCoords(t.pageX, t.pageY);\r\n        }\r\n      };\r\n\r\n      _onTouchEnd = () => {\r\n        this.isHoverInside = false;\r\n      };\r\n      _onMouseEnter = () => {\r\n        this.isHoverInside = true;\r\n      };\r\n      _onMouseLeave = () => {\r\n        this.isHoverInside = false;\r\n      };\r\n\r\n      update() {\r\n        if (this.takeoverActive) {\r\n          const t =\r\n            (performance.now() - this.takeoverStartTime) /\r\n            (this.takeoverDuration * 1000);\r\n          if (t >= 1) {\r\n            this.takeoverActive = false;\r\n            this.coords.copy(this.takeoverTo);\r\n            this.coords_old.copy(this.coords);\r\n            this.diff.set(0, 0);\r\n          } else {\r\n            const k = t * t * (3 - 2 * t);\r\n            this.coords.copy(this.takeoverFrom).lerp(this.takeoverTo, k);\r\n          }\r\n        }\r\n        this.diff.subVectors(this.coords, this.coords_old);\r\n        this.coords_old.copy(this.coords);\r\n        if (this.coords_old.x === 0 && this.coords_old.y === 0)\r\n          this.diff.set(0, 0);\r\n        if (this.isAutoActive && !this.takeoverActive)\r\n          this.diff.multiplyScalar(this.autoIntensity);\r\n      }\r\n    }\r\n\r\n    class AutoDriver {\r\n      mouse: MouseClass;\r\n      manager: any;\r\n      enabled: boolean;\r\n      speed: number;\r\n      resumeDelay: number;\r\n      rampDurationMs: number;\r\n      active = false;\r\n      current = new THREE.Vector2(0, 0);\r\n      target = new THREE.Vector2();\r\n      lastTime = performance.now();\r\n      activationTime = 0;\r\n      margin = 0.2;\r\n      _tmpDir = new THREE.Vector2();\r\n\r\n      constructor(mouse: MouseClass, manager: any, opts: any) {\r\n        this.mouse = mouse;\r\n        this.manager = manager;\r\n        this.enabled = opts.enabled;\r\n        this.speed = opts.speed;\r\n        this.resumeDelay = opts.resumeDelay || 3000;\r\n        this.rampDurationMs = (opts.rampDuration || 0) * 1000;\r\n        this.pickNewTarget();\r\n      }\r\n\r\n      pickNewTarget() {\r\n        const r = Math.random;\r\n        this.target.set(\r\n          (r() * 2 - 1) * (1 - this.margin),\r\n          (r() * 2 - 1) * (1 - this.margin)\r\n        );\r\n      }\r\n\r\n      forceStop() {\r\n        this.active = false;\r\n        this.mouse.isAutoActive = false;\r\n      }\r\n\r\n      update() {\r\n        if (!this.enabled) return;\r\n        const now = performance.now();\r\n        const idle = now - this.manager.lastUserInteraction;\r\n        if (idle < this.resumeDelay) {\r\n          if (this.active) this.forceStop();\r\n          return;\r\n        }\r\n        if (this.mouse.isHoverInside) {\r\n          if (this.active) this.forceStop();\r\n          return;\r\n        }\r\n        if (!this.active) {\r\n          this.active = true;\r\n          this.current.copy(this.mouse.coords);\r\n          this.lastTime = now;\r\n          this.activationTime = now;\r\n        }\r\n        if (!this.active) return;\r\n        this.mouse.isAutoActive = true;\r\n        let dtSec = (now - this.lastTime) / 1000;\r\n        this.lastTime = now;\r\n        if (dtSec > 0.2) dtSec = 0.016;\r\n\r\n        const dir = this._tmpDir.subVectors(this.target, this.current);\r\n        const dist = dir.length();\r\n        if (dist < 0.01) {\r\n          this.pickNewTarget();\r\n          return;\r\n        }\r\n        dir.normalize();\r\n        let ramp = 1;\r\n        if (this.rampDurationMs > 0) {\r\n          const t = Math.min(\r\n            1,\r\n            (now - this.activationTime) / this.rampDurationMs\r\n          );\r\n          ramp = t * t * (3 - 2 * t);\r\n        }\r\n        const step = this.speed * dtSec * ramp;\r\n        const move = Math.min(step, dist);\r\n        this.current.addScaledVector(dir, move);\r\n        this.mouse.setNormalized(this.current.x, this.current.y);\r\n      }\r\n    }\r\n\r\n    // --- 2. Shaders ---\r\n    const face_vert = `\r\n      attribute vec3 position;\r\n      uniform vec2 px;\r\n      uniform vec2 boundarySpace;\r\n      varying vec2 uv;\r\n      precision highp float;\r\n      void main(){\r\n        vec3 pos = position;\r\n        vec2 scale = 1.0 - boundarySpace * 2.0;\r\n        pos.xy = pos.xy * scale;\r\n        uv = vec2(0.5)+(pos.xy)*0.5;\r\n        gl_Position = vec4(pos, 1.0);\r\n      }\r\n    `;\r\n\r\n    const line_vert = `\r\n      attribute vec3 position;\r\n      uniform vec2 px;\r\n      precision highp float;\r\n      varying vec2 uv;\r\n      void main(){\r\n        vec3 pos = position;\r\n        uv = 0.5 + pos.xy * 0.5;\r\n        vec2 n = sign(pos.xy);\r\n        pos.xy = abs(pos.xy) - px * 1.0;\r\n        pos.xy *= n;\r\n        gl_Position = vec4(pos, 1.0);\r\n      }\r\n    `;\r\n\r\n    const mouse_vert = `\r\n      precision highp float;\r\n      attribute vec3 position;\r\n      attribute vec2 uv;\r\n      uniform vec2 center;\r\n      uniform vec2 scale;\r\n      uniform vec2 px;\r\n      varying vec2 vUv;\r\n      void main(){\r\n        vec2 pos = position.xy * scale * 2.0 * px + center;\r\n        vUv = uv;\r\n        gl_Position = vec4(pos, 0.0, 1.0);\r\n      }\r\n    `;\r\n\r\n    const advection_frag = `\r\n      precision highp float;\r\n      uniform sampler2D velocity;\r\n      uniform float dt;\r\n      uniform bool isBFECC;\r\n      uniform vec2 fboSize;\r\n      uniform vec2 px;\r\n      varying vec2 uv;\r\n      void main(){\r\n        vec2 ratio = max(fboSize.x, fboSize.y) / fboSize;\r\n        if(isBFECC == false){\r\n          vec2 vel = texture2D(velocity, uv).xy;\r\n          vec2 uv2 = uv - vel * dt * ratio;\r\n          vec2 newVel = texture2D(velocity, uv2).xy;\r\n          gl_FragColor = vec4(newVel, 0.0, 0.0);\r\n        } else {\r\n          vec2 spot_new = uv;\r\n          vec2 vel_old = texture2D(velocity, uv).xy;\r\n          vec2 spot_old = spot_new - vel_old * dt * ratio;\r\n          vec2 vel_new1 = texture2D(velocity, spot_old).xy;\r\n          vec2 spot_new2 = spot_old + vel_new1 * dt * ratio;\r\n          vec2 error = spot_new2 - spot_new;\r\n          vec2 spot_new3 = spot_new - error / 2.0;\r\n          vec2 vel_2 = texture2D(velocity, spot_new3).xy;\r\n          vec2 spot_old2 = spot_new3 - vel_2 * dt * ratio;\r\n          vec2 newVel2 = texture2D(velocity, spot_old2).xy;\r\n          gl_FragColor = vec4(newVel2, 0.0, 0.0);\r\n        }\r\n      }\r\n    `;\r\n\r\n    const color_frag = `\r\n      precision highp float;\r\n      uniform sampler2D velocity;\r\n      uniform sampler2D palette;\r\n      uniform vec4 bgColor;\r\n      varying vec2 uv;\r\n      void main(){\r\n        vec2 vel = texture2D(velocity, uv).xy;\r\n        float lenv = clamp(length(vel), 0.0, 1.0);\r\n        vec3 c = texture2D(palette, vec2(lenv, 0.5)).rgb;\r\n        vec3 outRGB = mix(bgColor.rgb, c, lenv);\r\n        float outA = mix(bgColor.a, 1.0, lenv);\r\n        gl_FragColor = vec4(outRGB, outA);\r\n      }\r\n    `;\r\n\r\n    const divergence_frag = `\r\n      precision highp float;\r\n      uniform sampler2D velocity;\r\n      uniform float dt;\r\n      uniform vec2 px;\r\n      varying vec2 uv;\r\n      void main(){\r\n        float x0 = texture2D(velocity, uv-vec2(px.x, 0.0)).x;\r\n        float x1 = texture2D(velocity, uv+vec2(px.x, 0.0)).x;\r\n        float y0 = texture2D(velocity, uv-vec2(0.0, px.y)).y;\r\n        float y1 = texture2D(velocity, uv+vec2(0.0, px.y)).y;\r\n        float divergence = (x1 - x0 + y1 - y0) / 2.0;\r\n        gl_FragColor = vec4(divergence / dt);\r\n      }\r\n    `;\r\n\r\n    const externalForce_frag = `\r\n      precision highp float;\r\n      uniform vec2 force;\r\n      uniform vec2 center;\r\n      uniform vec2 scale;\r\n      uniform vec2 px;\r\n      varying vec2 vUv;\r\n      void main(){\r\n        vec2 circle = (vUv - 0.5) * 2.0;\r\n        float d = 1.0 - min(length(circle), 1.0);\r\n        d *= d;\r\n        gl_FragColor = vec4(force * d, 0.0, 1.0);\r\n      }\r\n    `;\r\n\r\n    const poisson_frag = `\r\n      precision highp float;\r\n      uniform sampler2D pressure;\r\n      uniform sampler2D divergence;\r\n      uniform vec2 px;\r\n      varying vec2 uv;\r\n      void main(){\r\n        float p0 = texture2D(pressure, uv + vec2(px.x * 2.0, 0.0)).r;\r\n        float p1 = texture2D(pressure, uv - vec2(px.x * 2.0, 0.0)).r;\r\n        float p2 = texture2D(pressure, uv + vec2(0.0, px.y * 2.0)).r;\r\n        float p3 = texture2D(pressure, uv - vec2(0.0, px.y * 2.0)).r;\r\n        float div = texture2D(divergence, uv).r;\r\n        float newP = (p0 + p1 + p2 + p3) / 4.0 - div;\r\n        gl_FragColor = vec4(newP);\r\n      }\r\n    `;\r\n\r\n    const pressure_frag = `\r\n      precision highp float;\r\n      uniform sampler2D pressure;\r\n      uniform sampler2D velocity;\r\n      uniform vec2 px;\r\n      uniform float dt;\r\n      varying vec2 uv;\r\n      void main(){\r\n        float step = 1.0;\r\n        float p0 = texture2D(pressure, uv + vec2(px.x * step, 0.0)).r;\r\n        float p1 = texture2D(pressure, uv - vec2(px.x * step, 0.0)).r;\r\n        float p2 = texture2D(pressure, uv + vec2(0.0, px.y * step)).r;\r\n        float p3 = texture2D(pressure, uv - vec2(0.0, px.y * step)).r;\r\n        vec2 v = texture2D(velocity, uv).xy;\r\n        vec2 gradP = vec2(p0 - p1, p2 - p3) * 0.5;\r\n        v = v - gradP * dt;\r\n        gl_FragColor = vec4(v, 0.0, 1.0);\r\n      }\r\n    `;\r\n\r\n    const viscous_frag = `\r\n      precision highp float;\r\n      uniform sampler2D velocity;\r\n      uniform sampler2D velocity_new;\r\n      uniform float v;\r\n      uniform vec2 px;\r\n      uniform float dt;\r\n      varying vec2 uv;\r\n      void main(){\r\n        vec2 old = texture2D(velocity, uv).xy;\r\n        vec2 new0 = texture2D(velocity_new, uv + vec2(px.x * 2.0, 0.0)).xy;\r\n        vec2 new1 = texture2D(velocity_new, uv - vec2(px.x * 2.0, 0.0)).xy;\r\n        vec2 new2 = texture2D(velocity_new, uv + vec2(0.0, px.y * 2.0)).xy;\r\n        vec2 new3 = texture2D(velocity_new, uv - vec2(0.0, px.y * 2.0)).xy;\r\n        vec2 newv = 4.0 * old + v * dt * (new0 + new1 + new2 + new3);\r\n        newv /= 4.0 * (1.0 + v * dt);\r\n        gl_FragColor = vec4(newv, 0.0, 0.0);\r\n      }\r\n    `;\r\n\r\n\r\n    // --- 3. Instances inside component scope ---\r\n    const Common = new CommonClass();\r\n    const Mouse = new MouseClass();\r\n    \r\n    // --- 4. Simulation Classes ---\r\n    class ShaderPass {\r\n      props: any;\r\n      uniforms: any;\r\n      scene: THREE.Scene;\r\n      camera: THREE.Camera;\r\n      material: THREE.RawShaderMaterial | null = null;\r\n      geometry: THREE.PlaneGeometry | null = null;\r\n      plane: THREE.Mesh | null = null;\r\n\r\n      constructor(props: any) {\r\n        this.props = props || {};\r\n        this.uniforms = this.props.material?.uniforms;\r\n        this.scene = new THREE.Scene();\r\n        this.camera = new THREE.Camera();\r\n      }\r\n\r\n      init() {\r\n        if (this.uniforms) {\r\n          this.material = new THREE.RawShaderMaterial(this.props.material);\r\n          this.geometry = new THREE.PlaneGeometry(2, 2);\r\n          this.plane = new THREE.Mesh(this.geometry, this.material);\r\n          this.scene.add(this.plane);\r\n        }\r\n      }\r\n\r\n      run() {\r\n        if(!Common.renderer) return;\r\n        Common.renderer.setRenderTarget(this.props.output || null);\r\n        Common.renderer.render(this.scene, this.camera);\r\n        Common.renderer.setRenderTarget(null);\r\n      }\r\n    }\r\n\r\n    class Advection extends ShaderPass {\r\n      line: THREE.LineSegments | null = null;\r\n\r\n      constructor(simProps: any) {\r\n        super({\r\n          material: {\r\n            vertexShader: face_vert,\r\n            fragmentShader: advection_frag,\r\n            uniforms: {\r\n              boundarySpace: { value: simProps.cellScale },\r\n              px: { value: simProps.cellScale },\r\n              fboSize: { value: simProps.fboSize },\r\n              velocity: { value: simProps.src.texture },\r\n              dt: { value: simProps.dt },\r\n              isBFECC: { value: true },\r\n            },\r\n          },\r\n          output: simProps.dst,\r\n        });\r\n        this.init();\r\n      }\r\n\r\n      init() {\r\n        super.init();\r\n        this.createBoundary();\r\n      }\r\n\r\n      createBoundary() {\r\n        const boundaryG = new THREE.BufferGeometry();\r\n        const vertices_boundary = new Float32Array([\r\n          -1, -1, 0, -1, 1, 0, -1, 1, 0, 1, 1, 0, 1, 1, 0, 1, -1, 0, 1, -1, 0, -1, -1, 0,\r\n        ]);\r\n        boundaryG.setAttribute(\r\n          \"position\",\r\n          new THREE.BufferAttribute(vertices_boundary, 3)\r\n        );\r\n        const boundaryM = new THREE.RawShaderMaterial({\r\n          vertexShader: line_vert,\r\n          fragmentShader: advection_frag,\r\n          uniforms: this.uniforms,\r\n        });\r\n        this.line = new THREE.LineSegments(boundaryG, boundaryM);\r\n        this.scene.add(this.line);\r\n      }\r\n\r\n      update({ dt, isBounce, BFECC }: any) {\r\n        this.uniforms.dt.value = dt;\r\n        if(this.line) this.line.visible = isBounce;\r\n        this.uniforms.isBFECC.value = BFECC;\r\n        super.run();\r\n      }\r\n    }\r\n\r\n    class ExternalForce extends ShaderPass {\r\n      mouse: THREE.Mesh | null = null;\r\n\r\n      constructor(simProps: any) {\r\n        super({ output: simProps.dst });\r\n        this.init(simProps);\r\n      }\r\n\r\n      init(simProps?: any) {\r\n        super.init();\r\n        if (!simProps) return;\r\n        const mouseG = new THREE.PlaneGeometry(1, 1);\r\n        const mouseM = new THREE.RawShaderMaterial({\r\n          vertexShader: mouse_vert,\r\n          fragmentShader: externalForce_frag,\r\n          blending: THREE.AdditiveBlending,\r\n          depthWrite: false,\r\n          uniforms: {\r\n            px: { value: simProps.cellScale },\r\n            force: { value: new THREE.Vector2(0, 0) },\r\n            center: { value: new THREE.Vector2(0, 0) },\r\n            scale: {\r\n              value: new THREE.Vector2(simProps.cursor_size, simProps.cursor_size),\r\n            },\r\n          },\r\n        });\r\n        this.mouse = new THREE.Mesh(mouseG, mouseM);\r\n        this.scene.add(this.mouse);\r\n      }\r\n\r\n      update(props: any) {\r\n        const forceX = (Mouse.diff.x / 2) * props.mouse_force;\r\n        const forceY = (Mouse.diff.y / 2) * props.mouse_force;\r\n        const cursorSizeX = props.cursor_size * props.cellScale.x;\r\n        const cursorSizeY = props.cursor_size * props.cellScale.y;\r\n        const centerX = Math.min(\r\n          Math.max(Mouse.coords.x, -1 + cursorSizeX + props.cellScale.x * 2),\r\n          1 - cursorSizeX - props.cellScale.x * 2\r\n        );\r\n        const centerY = Math.min(\r\n          Math.max(Mouse.coords.y, -1 + cursorSizeY + props.cellScale.y * 2),\r\n          1 - cursorSizeY - props.cellScale.y * 2\r\n        );\r\n        \r\n        if (this.mouse) {\r\n          const uniforms = (this.mouse.material as THREE.RawShaderMaterial).uniforms;\r\n          uniforms.force.value.set(forceX, forceY);\r\n          uniforms.center.value.set(centerX, centerY);\r\n          uniforms.scale.value.set(props.cursor_size, props.cursor_size);\r\n        }\r\n        super.run();\r\n      }\r\n    }\r\n\r\n    class Viscous extends ShaderPass {\r\n      constructor(simProps: any) {\r\n        super({\r\n          material: {\r\n            vertexShader: face_vert,\r\n            fragmentShader: viscous_frag,\r\n            uniforms: {\r\n              boundarySpace: { value: simProps.boundarySpace },\r\n              velocity: { value: simProps.src.texture },\r\n              velocity_new: { value: simProps.dst_.texture },\r\n              v: { value: simProps.viscous },\r\n              px: { value: simProps.cellScale },\r\n              dt: { value: simProps.dt },\r\n            },\r\n          },\r\n          output: simProps.dst,\r\n          output0: simProps.dst_,\r\n          output1: simProps.dst,\r\n        });\r\n        this.init();\r\n      }\r\n\r\n      update({ viscous, iterations, dt }: any) {\r\n        let fbo_in, fbo_out;\r\n        this.uniforms.v.value = viscous;\r\n        for (let i = 0; i < iterations; i++) {\r\n          if (i % 2 === 0) {\r\n            fbo_in = this.props.output0;\r\n            fbo_out = this.props.output1;\r\n          } else {\r\n            fbo_in = this.props.output1;\r\n            fbo_out = this.props.output0;\r\n          }\r\n          this.uniforms.velocity_new.value = fbo_in.texture;\r\n          this.props.output = fbo_out;\r\n          this.uniforms.dt.value = dt;\r\n          super.run();\r\n        }\r\n        return fbo_out;\r\n      }\r\n    }\r\n\r\n    class Divergence extends ShaderPass {\r\n      constructor(simProps: any) {\r\n        super({\r\n          material: {\r\n            vertexShader: face_vert,\r\n            fragmentShader: divergence_frag,\r\n            uniforms: {\r\n              boundarySpace: { value: simProps.boundarySpace },\r\n              velocity: { value: simProps.src.texture },\r\n              px: { value: simProps.cellScale },\r\n              dt: { value: simProps.dt },\r\n            },\r\n          },\r\n          output: simProps.dst,\r\n        });\r\n        this.init();\r\n      }\r\n\r\n      update({ vel }: any) {\r\n        this.uniforms.velocity.value = vel.texture;\r\n        super.run();\r\n      }\r\n    }\r\n\r\n    class Poisson extends ShaderPass {\r\n      constructor(simProps: any) {\r\n        super({\r\n          material: {\r\n            vertexShader: face_vert,\r\n            fragmentShader: poisson_frag,\r\n            uniforms: {\r\n              boundarySpace: { value: simProps.boundarySpace },\r\n              pressure: { value: simProps.dst_.texture },\r\n              divergence: { value: simProps.src.texture },\r\n              px: { value: simProps.cellScale },\r\n            },\r\n          },\r\n          output: simProps.dst,\r\n          output0: simProps.dst_,\r\n          output1: simProps.dst,\r\n        });\r\n        this.init();\r\n      }\r\n\r\n      update({ iterations }: any) {\r\n        let p_in, p_out;\r\n        for (let i = 0; i < iterations; i++) {\r\n          if (i % 2 === 0) {\r\n            p_in = this.props.output0;\r\n            p_out = this.props.output1;\r\n          } else {\r\n            p_in = this.props.output1;\r\n            p_out = this.props.output0;\r\n          }\r\n          this.uniforms.pressure.value = p_in.texture;\r\n          this.props.output = p_out;\r\n          super.run();\r\n        }\r\n        return p_out;\r\n      }\r\n    }\r\n\r\n    class Pressure extends ShaderPass {\r\n      constructor(simProps: any) {\r\n        super({\r\n          material: {\r\n            vertexShader: face_vert,\r\n            fragmentShader: pressure_frag,\r\n            uniforms: {\r\n              boundarySpace: { value: simProps.boundarySpace },\r\n              pressure: { value: simProps.src_p.texture },\r\n              velocity: { value: simProps.src_v.texture },\r\n              px: { value: simProps.cellScale },\r\n              dt: { value: simProps.dt },\r\n            },\r\n          },\r\n          output: simProps.dst,\r\n        });\r\n        this.init();\r\n      }\r\n\r\n      update({ vel, pressure }: any) {\r\n        this.uniforms.velocity.value = vel.texture;\r\n        this.uniforms.pressure.value = pressure.texture;\r\n        super.run();\r\n      }\r\n    }\r\n\r\n    class Simulation {\r\n      options: any;\r\n      fbos: any;\r\n      fboSize = new THREE.Vector2();\r\n      cellScale = new THREE.Vector2();\r\n      boundarySpace = new THREE.Vector2();\r\n      advection: Advection | null = null;\r\n      externalForce: ExternalForce | null = null;\r\n      viscous: Viscous | null = null;\r\n      divergence: Divergence | null = null;\r\n      poisson: Poisson | null = null;\r\n      pressure: Pressure | null = null;\r\n\r\n      constructor(options: any) {\r\n        this.options = options;\r\n        this.fbos = {\r\n          vel_0: null,\r\n          vel_1: null,\r\n          vel_viscous0: null,\r\n          vel_viscous1: null,\r\n          div: null,\r\n          pressure_0: null,\r\n          pressure_1: null,\r\n        };\r\n        this.init();\r\n      }\r\n\r\n      init() {\r\n        this.calcSize();\r\n        this.createAllFBO();\r\n        this.createShaderPass();\r\n      }\r\n\r\n      calcSize() {\r\n        const width = Math.max(1, Math.round(this.options.resolution * Common.width));\r\n        const height = Math.max(1, Math.round(this.options.resolution * Common.height));\r\n        const px_x = 1 / width;\r\n        const px_y = 1 / height;\r\n        this.cellScale.set(px_x, px_y);\r\n        this.fboSize.set(width, height);\r\n      }\r\n      \r\n      getFloatType() {\r\n        // We can just return THREE.FloatType or HalfFloatType. \r\n        // Some mobile devices might need HalfFloatType, but modern ones support FloatType mostly.\r\n        const isIOS = /(iPad|iPhone|iPod)/i.test(navigator.userAgent);\r\n        return isIOS ? THREE.HalfFloatType : THREE.FloatType;\r\n      }\r\n\r\n      createAllFBO() {\r\n        const type = this.getFloatType();\r\n        const opts = {\r\n          type,\r\n          depthBuffer: false,\r\n          stencilBuffer: false,\r\n          minFilter: THREE.LinearFilter,\r\n          magFilter: THREE.LinearFilter,\r\n          wrapS: THREE.ClampToEdgeWrapping,\r\n          wrapT: THREE.ClampToEdgeWrapping,\r\n        };\r\n        for (let key in this.fbos) {\r\n          this.fbos[key] = new THREE.WebGLRenderTarget(\r\n            this.fboSize.x,\r\n            this.fboSize.y,\r\n            opts\r\n          );\r\n        }\r\n      }\r\n\r\n      createShaderPass() {\r\n        this.advection = new Advection({\r\n          cellScale: this.cellScale,\r\n          fboSize: this.fboSize,\r\n          dt: this.options.dt,\r\n          src: this.fbos.vel_0,\r\n          dst: this.fbos.vel_1,\r\n        });\r\n        this.externalForce = new ExternalForce({\r\n          cellScale: this.cellScale,\r\n          cursor_size: this.options.cursor_size,\r\n          dst: this.fbos.vel_1,\r\n        });\r\n        this.viscous = new Viscous({\r\n          cellScale: this.cellScale,\r\n          boundarySpace: this.boundarySpace,\r\n          viscous: this.options.viscous,\r\n          src: this.fbos.vel_1,\r\n          dst: this.fbos.vel_viscous1,\r\n          dst_: this.fbos.vel_viscous0,\r\n          dt: this.options.dt,\r\n        });\r\n        this.divergence = new Divergence({\r\n          cellScale: this.cellScale,\r\n          boundarySpace: this.boundarySpace,\r\n          src: this.fbos.vel_viscous0,\r\n          dst: this.fbos.div,\r\n          dt: this.options.dt,\r\n        });\r\n        this.poisson = new Poisson({\r\n          cellScale: this.cellScale,\r\n          boundarySpace: this.boundarySpace,\r\n          src: this.fbos.div,\r\n          dst: this.fbos.pressure_1,\r\n          dst_: this.fbos.pressure_0,\r\n        });\r\n        this.pressure = new Pressure({\r\n          cellScale: this.cellScale,\r\n          boundarySpace: this.boundarySpace,\r\n          src_p: this.fbos.pressure_0,\r\n          src_v: this.fbos.vel_viscous0,\r\n          dst: this.fbos.vel_0,\r\n          dt: this.options.dt,\r\n        });\r\n      }\r\n\r\n      resize() {\r\n        this.calcSize();\r\n        for (let key in this.fbos) {\r\n          this.fbos[key].setSize(this.fboSize.x, this.fboSize.y);\r\n        }\r\n      }\r\n\r\n      update() {\r\n        if (this.options.isBounce) {\r\n          this.boundarySpace.set(0, 0);\r\n        } else {\r\n          this.boundarySpace.copy(this.cellScale);\r\n        }\r\n        if (this.advection) this.advection.update({\r\n          dt: this.options.dt,\r\n          isBounce: this.options.isBounce,\r\n          BFECC: this.options.BFECC,\r\n        });\r\n        if (this.externalForce) this.externalForce.update({\r\n          cursor_size: this.options.cursor_size,\r\n          mouse_force: this.options.mouse_force,\r\n          cellScale: this.cellScale,\r\n        });\r\n        let vel = this.fbos.vel_1;\r\n        if (this.options.isViscous && this.viscous) {\r\n          vel = this.viscous.update({\r\n            viscous: this.options.viscous,\r\n            iterations: this.options.iterations_viscous,\r\n            dt: this.options.dt,\r\n          });\r\n        }\r\n        if (this.divergence) this.divergence.update({ vel });\r\n        if (this.poisson) {\r\n           const pressure = this.poisson.update({\r\n              iterations: this.options.iterations_poisson,\r\n           });\r\n           if (this.pressure) this.pressure.update({ vel, pressure });\r\n        }\r\n      }\r\n    }\r\n\r\n    class Output {\r\n      simulation: Simulation;\r\n      scene: THREE.Scene;\r\n      camera: THREE.Camera;\r\n      output: THREE.Mesh | null = null;\r\n\r\n      constructor() {\r\n        this.scene = new THREE.Scene();\r\n        this.camera = new THREE.Camera();\r\n        \r\n        // Dynamic palette texture generation\r\n        const colors = [color1, color2, color3].filter(Boolean) as string[];\r\n\r\n        function makePaletteTexture(stops: string[]) {\r\n            let arr: string[];\r\n            if (Array.isArray(stops) && stops.length > 0) {\r\n              if (stops.length === 1) {\r\n                arr = [stops[0], stops[0]];\r\n              } else {\r\n                arr = stops;\r\n              }\r\n            } else {\r\n              arr = [\"#ffffff\", \"#ffffff\"];\r\n            }\r\n            const w = arr.length;\r\n            const data = new Uint8Array(w * 4);\r\n            for (let i = 0; i < w; i++) {\r\n              const c = new THREE.Color(arr[i]);\r\n              data[i * 4 + 0] = Math.round(c.r * 255);\r\n              data[i * 4 + 1] = Math.round(c.g * 255);\r\n              data[i * 4 + 2] = Math.round(c.b * 255);\r\n              data[i * 4 + 3] = 255;\r\n            }\r\n            const tex = new THREE.DataTexture(data, w, 1, THREE.RGBAFormat);\r\n            tex.magFilter = THREE.LinearFilter;\r\n            tex.minFilter = THREE.LinearFilter;\r\n            tex.wrapS = THREE.ClampToEdgeWrapping;\r\n            tex.wrapT = THREE.ClampToEdgeWrapping;\r\n            tex.needsUpdate = true;\r\n            return tex;\r\n        }\r\n\r\n        const paletteTex = makePaletteTexture(colors);\r\n        const bgVec4 = new THREE.Vector4(0, 0, 0, 0); // Transparent background\r\n\r\n        this.simulation = new Simulation({\r\n            iterations_poisson: iterationsPoisson,\r\n            iterations_viscous: iterationsViscous,\r\n            mouse_force: mouseForce,\r\n            resolution: resolution,\r\n            cursor_size: cursorSize,\r\n            viscous: viscous,\r\n            isBounce: isBounce,\r\n            dt: dt,\r\n            isViscous: isViscous,\r\n            BFECC: BFECC,\r\n        });\r\n\r\n        this.output = new THREE.Mesh(\r\n            new THREE.PlaneGeometry(2, 2),\r\n            new THREE.RawShaderMaterial({\r\n                vertexShader: face_vert,\r\n                fragmentShader: color_frag,\r\n                transparent: true,\r\n                depthWrite: false,\r\n                uniforms: {\r\n                    velocity: { value: this.simulation.fbos.vel_0.texture },\r\n                    boundarySpace: { value: new THREE.Vector2() },\r\n                    palette: { value: paletteTex },\r\n                    bgColor: { value: bgVec4 },\r\n                }\r\n            })\r\n        );\r\n        this.scene.add(this.output);\r\n      }\r\n\r\n      resize() {\r\n        this.simulation.resize();\r\n      }\r\n\r\n      update() {\r\n        this.simulation.update();\r\n        if(Common.renderer) {\r\n            Common.renderer.setRenderTarget(null);\r\n            Common.renderer.render(this.scene, this.camera);\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    class WebGLManager {\r\n      output: Output | null = null;\r\n      running = false;\r\n      autoDriver: AutoDriver | null = null;\r\n      lastUserInteraction = 0;\r\n\r\n      constructor(wrapper: HTMLElement | null) {\r\n        if (!wrapper) return;\r\n        Common.init(wrapper);\r\n        Mouse.init(wrapper);\r\n        wrapper.prepend(Common.renderer!.domElement);\r\n\r\n        this.output = new Output();\r\n        this.lastUserInteraction = performance.now();\r\n        Mouse.onInteract = () => {\r\n            this.lastUserInteraction = performance.now();\r\n            if (this.autoDriver) this.autoDriver.forceStop();\r\n        };\r\n        Mouse.autoIntensity = autoIntensity;\r\n        Mouse.takeoverDuration = takeoverDuration;\r\n        \r\n        this.autoDriver = new AutoDriver(Mouse, this, {\r\n            enabled: autoDemo,\r\n            speed: autoSpeed,\r\n            resumeDelay: autoResumeDelay,\r\n            rampDuration: autoRampDuration,\r\n        });\r\n      }\r\n\r\n      resize() {\r\n        Common.resize();\r\n        if(this.output) this.output.resize();\r\n      }\r\n\r\n      render() {\r\n        if (this.autoDriver) this.autoDriver.update();\r\n        Mouse.update();\r\n        Common.update();\r\n        if(this.output) this.output.update();\r\n      }\r\n      \r\n      loop = () => {\r\n          if(!this.running) return;\r\n          this.render();\r\n          rafRef.current = requestAnimationFrame(this.loop);\r\n      }\r\n\r\n      start() {\r\n          if(this.running) return;\r\n          this.running = true;\r\n          this.loop();\r\n      }\r\n      \r\n      pause() {\r\n          this.running = false;\r\n          if(rafRef.current) {\r\n              cancelAnimationFrame(rafRef.current);\r\n              rafRef.current = null;\r\n          }\r\n      }\r\n\r\n      dispose() {\r\n          this.pause();\r\n          Mouse.dispose();\r\n          Common.dispose();\r\n      }\r\n    }\r\n\r\n    // --- 5. Initializing Logic ---\r\n    const wrapper = mountRef.current;\r\n    \r\n    // Cleanup any existing canvas\r\n    if(wrapper.querySelector('canvas')) {\r\n        wrapper.innerHTML = '';\r\n        wrapper.appendChild(document.createElement('style')).textContent = `\r\n          .liquid-ether-container { position: relative; overflow: hidden; width: 100%; height: 100%; touch-action: none; }\r\n        `;\r\n    } else {\r\n        wrapper.appendChild(document.createElement('style')).textContent = `\r\n          .liquid-ether-container { position: relative; overflow: hidden; width: 100%; height: 100%; touch-action: none; }\r\n        `;\r\n    }\r\n\r\n    const webgl = new WebGLManager(wrapper);\r\n    webglRef.current = webgl;\r\n    webgl.start();\r\n\r\n    // Resize Observer\r\n    const ro = new ResizeObserver(() => {\r\n        if (resizeRafRef.current) cancelAnimationFrame(resizeRafRef.current);\r\n        resizeRafRef.current = requestAnimationFrame(() => {\r\n           if(webglRef.current) webglRef.current.resize();\r\n        });\r\n    });\r\n    ro.observe(wrapper);\r\n    resizeObserverRef.current = ro;\r\n\r\n    // Visibility (Intersection) Observer\r\n    const io = new IntersectionObserver((entries) => {\r\n        const entry = entries[0];\r\n        const isVisible = entry.isIntersecting; // && entry.intersectionRatio > 0;\r\n        isVisibleRef.current = isVisible;\r\n        if(webglRef.current) {\r\n            if(isVisible && !document.hidden) {\r\n                webglRef.current.start();\r\n            } else {\r\n                webglRef.current.pause();\r\n            }\r\n        }\r\n    }, { threshold: 0 });\r\n    io.observe(wrapper);\r\n    intersectionObserverRef.current = io;\r\n\r\n    // Visibility Change\r\n    const onVisibilityChange = () => {\r\n        if(document.hidden) {\r\n            if(webglRef.current) webglRef.current.pause();\r\n        } else if(isVisibleRef.current) {\r\n            if(webglRef.current) webglRef.current.start();\r\n        }\r\n    };\r\n    document.addEventListener(\"visibilitychange\", onVisibilityChange);\r\n\r\n    return () => {\r\n        if (rafRef.current) cancelAnimationFrame(rafRef.current);\r\n        if (resizeObserverRef.current) resizeObserverRef.current.disconnect();\r\n        if (intersectionObserverRef.current) intersectionObserverRef.current.disconnect();\r\n        document.removeEventListener(\"visibilitychange\", onVisibilityChange);\r\n        if (webglRef.current) webglRef.current.dispose();\r\n        if (wrapper && wrapper.querySelector('canvas')) {\r\n          wrapper.innerHTML = ''; // Clear canvas\r\n        }\r\n        Common.dispose(); // Ensure Three.js context is cleaned\r\n        Mouse.dispose();\r\n    };\r\n  }, [\r\n    color1, color2, color3, mouseForce, cursorSize, isViscous, viscous, \r\n    iterationsViscous, iterationsPoisson, dt, BFECC, resolution, isBounce,\r\n    autoDemo, autoSpeed, autoIntensity, takeoverDuration, autoResumeDelay, autoRampDuration\r\n  ]);\r\n\r\n  return (\r\n    <div\r\n      ref={mountRef}\r\n      className={`liquid-ether-container ${className || \"\"}`}\r\n      style={{\r\n        width: \"100%\",\r\n        height: \"100%\",\r\n        position: \"relative\",\r\n        overflow: \"hidden\",\r\n        ...style,\r\n      }}\r\n    />\r\n  );\r\n}\r\n",
      "type": "registry:ui",
      "target": "components/rareui/interactive-background/LiquidWave.tsx"
    }
  ]
}