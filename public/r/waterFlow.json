{
  "name": "waterFlow",
  "type": "registry:ui",
  "dependencies": [
    "react",
    "@types/react",
    "typescript"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "components/rareui/shaders/waterFlow.tsx",
      "content": "'use client';\r\n\r\nimport React, { useState, useEffect, useRef } from 'react';\r\n\r\n/**\r\n * HOOKS\r\n */\r\n\r\nconst useSmoothMouse = () => {\r\n  const [mouse, setMouse] = useState({ x: -9999, y: -9999, vx: 0, vy: 0, pressed: 0 });\r\n  const targetMouse = useRef({ x: -9999, y: -9999 });\r\n  const currentMouse = useRef({ x: -9999, y: -9999 });\r\n  const prevMouse = useRef({ x: -9999, y: -9999 });\r\n  const pressedTime = useRef(0);\r\n  const isPressed = useRef(false);\r\n  const animationFrame = useRef<number | null>(null);\r\n\r\n  useEffect(() => {\r\n    const handleMouseMove = (event: MouseEvent) => {\r\n      targetMouse.current = { x: event.clientX, y: event.clientY };\r\n    };\r\n    \r\n    const handleMouseDown = () => {\r\n      isPressed.current = true;\r\n      pressedTime.current = 0;\r\n    };\r\n    \r\n    const handleMouseUp = () => {\r\n      isPressed.current = false;\r\n    };\r\n    \r\n    const handleMouseLeave = () => {\r\n      targetMouse.current = { x: -9999, y: -9999 };\r\n      isPressed.current = false;\r\n    };\r\n\r\n    const updateMouse = () => {\r\n      // Smooth linear interpolation for fluid cursor movement\r\n      currentMouse.current.x += (targetMouse.current.x - currentMouse.current.x) * 0.15;\r\n      currentMouse.current.y += (targetMouse.current.y - currentMouse.current.y) * 0.15;\r\n      \r\n      // Calculate velocity\r\n      const vx = currentMouse.current.x - prevMouse.current.x;\r\n      const vy = currentMouse.current.y - prevMouse.current.y;\r\n      \r\n      // Accumulate press time\r\n      if (isPressed.current) {\r\n        pressedTime.current = Math.min(pressedTime.current + 0.05, 3.0);\r\n      } else {\r\n        pressedTime.current = Math.max(pressedTime.current - 0.1, 0);\r\n      }\r\n      \r\n      prevMouse.current = { ...currentMouse.current };\r\n      setMouse({ ...currentMouse.current, vx, vy, pressed: pressedTime.current });\r\n      animationFrame.current = requestAnimationFrame(updateMouse);\r\n    };\r\n\r\n    window.addEventListener('mousemove', handleMouseMove);\r\n    window.addEventListener('mousedown', handleMouseDown);\r\n    window.addEventListener('mouseup', handleMouseUp);\r\n    window.addEventListener('mouseleave', handleMouseLeave);\r\n    updateMouse();\r\n\r\n    return () => {\r\n      window.removeEventListener('mousemove', handleMouseMove);\r\n      window.removeEventListener('mousedown', handleMouseDown);\r\n      window.removeEventListener('mouseup', handleMouseUp);\r\n      window.removeEventListener('mouseleave', handleMouseLeave);\r\n      if (animationFrame.current) cancelAnimationFrame(animationFrame.current);\r\n    };\r\n  }, []);\r\n\r\n  return mouse;\r\n};\r\n\r\n/**\r\n * SHADER CODE (GLSL)\r\n */\r\n\r\nconst vertexShaderSource = `\r\n  attribute vec2 position;\r\n  varying vec2 vUv;\r\n  void main() {\r\n    vUv = position * 0.5 + 0.5;\r\n    gl_Position = vec4(position, 0.0, 1.0);\r\n  }\r\n`;\r\n\r\nconst fragmentShaderSource = `\r\n  precision highp float;\r\n  \r\n  uniform float u_time;\r\n  uniform vec2 u_resolution;\r\n  uniform vec2 u_mouse;\r\n  uniform vec2 u_velocity;\r\n  uniform float u_pressed;\r\n\r\n  // -- PHYSICS & CONFIGURATION --\r\n  const int ITERATIONS = 8;           // High iteration count for detailed micro-ripples\r\n  const vec3 SUN_DIR = normalize(vec3(-0.2, 0.4, -0.5)); // Sun position\r\n  const vec3 SUN_COLOR = vec3(1.2, 1.1, 1.0);            // Warm sunlight\r\n\r\n  // -- UTILS --\r\n  \r\n  // High-performance pseudo-random hash\r\n  vec2 hash(vec2 p) {\r\n    p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\r\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n  }\r\n\r\n  // Gradient Noise function\r\n  float noise(vec2 p) {\r\n    const float K1 = 0.366025404;\r\n    const float K2 = 0.211324865;\r\n    vec2 i = floor(p + (p.x+p.y)*K1);\r\n    vec2 a = p - i + (i.x+i.y)*K2;\r\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\r\n    vec2 b = a - o + K2;\r\n    vec2 c = a - 1.0 + 2.0*K2;\r\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n    return dot(n, vec3(70.0));\r\n  }\r\n\r\n  // -- WAVE GENERATION --\r\n  // Uses FBM (Fractal Brownian Motion) with domain warping to simulate water surface\r\n  float getWaves(vec2 p) {\r\n    float iter = 0.0;\r\n    float frequency = 0.8;\r\n    float timeMultiplier = u_time * 0.5;\r\n    float weight = 0.8;\r\n    float waveHeight = 0.0;\r\n    \r\n    // Rotation matrix for chaotic wave direction\r\n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\r\n    \r\n    for(int i=0; i<ITERATIONS; i++) {\r\n        // Sample noise\r\n        float d = noise(p * frequency + timeMultiplier);\r\n        \r\n        // \"Choppy\" Modifier:\r\n        // Real waves are peaked, not smooth sine waves. \r\n        // We invert the noise abs value to create sharp crests.\r\n        d = 1.0 - abs(d); \r\n        d = pow(d, 2.2); // Sharpening factor\r\n        \r\n        waveHeight += d * weight;\r\n        \r\n        // Evolve parameters for next octave\r\n        weight *= 0.5;      \r\n        frequency *= 1.18;  \r\n        p = m * p;          \r\n        timeMultiplier *= 1.07;\r\n    }\r\n    \r\n    return waveHeight;\r\n  }\r\n  \r\n  // -- CAUSTICS --\r\n  // Simulates light refraction hitting the ocean floor\r\n  float getCaustics(vec2 p) {\r\n      vec2 q = p * 2.0;\r\n      float d = noise(q + u_time * 0.5) * 0.5;\r\n      d += noise(q * 2.0 - u_time * 0.3) * 0.25;\r\n      // High contrast thresholding for \"light beam\" look\r\n      return pow(smoothstep(0.3, 0.8, d + 0.3), 3.0); \r\n  }\r\n\r\n  // -- ACES TONE MAPPING --\r\n  // Cinema-standard tone mapping to handle high dynamic range lighting naturally\r\n  vec3 aces_tonemap(vec3 color){  \r\n    mat3 m1 = mat3(\r\n        0.59719, 0.07600, 0.02840,\r\n        0.35458, 0.90834, 0.13383,\r\n        0.04823, 0.01566, 0.83777\r\n    );\r\n    mat3 m2 = mat3(\r\n        1.60475, -0.10208, -0.00327,\r\n        -0.53108,  1.10813, -0.07276,\r\n        -0.07367, -0.00605,  1.07602\r\n    );\r\n    vec3 v = m1 * color;    \r\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\r\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\r\n    return clamp(m2 * (a / b), 0.0, 1.0);  \r\n  }\r\n\r\n  void main() {\r\n      // 1. Setup Coordinates\r\n      vec2 uv = gl_FragCoord.xy / u_resolution.xy;\r\n      // Correct aspect ratio\r\n      vec2 p = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / min(u_resolution.x, u_resolution.y);\r\n      \r\n      // 2. Interactive Ripples\r\n      // Convert mouse to shader coords\r\n      vec2 mouse = (u_mouse / u_resolution) * 2.0 - 1.0;\r\n      mouse.x *= u_resolution.x / u_resolution.y;\r\n      \r\n      float dist = length(p - mouse);\r\n      vec2 toMouse = p - mouse;\r\n      \r\n      // Mouse velocity magnitude for flow strength\r\n      float speed = length(u_velocity) * 0.5;\r\n      vec2 flowDir = normalize(u_velocity + vec2(0.001)); // Avoid zero division\r\n      \r\n      // Natural water ripples - grow with press intensity\r\n      float pressIntensity = u_pressed * 0.5 + 1.0; // 1.0 to 2.5\r\n      float rippleRadius = 0.6 + u_pressed * 0.3; // Grows from 0.6 to 1.5\r\n      \r\n      float ripple1 = sin(dist * 25.0 - u_time * 8.0) * exp(-dist * 3.5) * pressIntensity;\r\n      float ripple2 = sin(dist * 40.0 - u_time * 13.0) * exp(-dist * 5.0) * 0.4 * pressIntensity;\r\n      float ripple = ripple1 + ripple2;\r\n      \r\n      // Influence area grows with press\r\n      float influence = smoothstep(rippleRadius, 0.0, dist);\r\n      \r\n      // Directional flow - water pushed in movement direction\r\n      float speedFactor = clamp(speed * 2.0, 0.0, 1.0);\r\n      vec2 flowDistortion = flowDir * speedFactor * influence * 0.15;\r\n      \r\n      // Subtle ripple refraction\r\n      vec2 rippleDistortion = normalize(toMouse) * ripple * influence * 0.06;\r\n      \r\n      p += rippleDistortion + flowDistortion;\r\n\r\n      // 3. Height & Normals Calculation\r\n      float h = getWaves(p * 2.0); \r\n      \r\n      // Calculate Normal Vector with ripple influence\r\n      vec2 e = vec2(0.01, 0.0);\r\n      float hx = getWaves((p + e.xy) * 2.0);\r\n      float hy = getWaves((p + e.yx) * 2.0);\r\n      \r\n      // Add ripple normals for realistic water surface\r\n      vec3 rippleNormal = vec3(-ripple * normalize(toMouse).x, 1.0, -ripple * normalize(toMouse).y) * influence;\r\n      vec3 normal = normalize(vec3(h - hx, 0.1, h - hy) + rippleNormal * 0.5);\r\n      \r\n      // 4. Lighting Calculation\r\n      vec3 viewDir = normalize(vec3(0.0, 1.0, 0.5));\r\n      \r\n      // Fresnel: Reflectivity increases at glancing angles\r\n      float fresnel = 0.02 + 0.98 * pow(1.0 - max(dot(viewDir, normal), 0.0), 4.0);\r\n      \r\n      // Sun Specular Highlight (Blinn-Phong model)\r\n      vec3 halfVec = normalize(SUN_DIR + viewDir);\r\n      float spec = pow(max(dot(normal, halfVec), 0.0), 180.0);\r\n      \r\n      // Caustics Pattern\r\n      // We project caustics based on the normal to make them \"swim\"\r\n      float caustics = getCaustics(p * 2.0 + normal.xz * 0.2);\r\n      \r\n      // 5. Coloring - #16dde4 Cyan Water\r\n      vec3 deepColor = vec3(0.05, 0.7, 0.8);     // Darker #16dde4\r\n      vec3 shallowColor = vec3(0.09, 0.87, 0.89); // #16dde4 (22, 221, 228)\r\n      \r\n      // Mix water color based on wave height\r\n      vec3 col = mix(deepColor, shallowColor, h * 0.5 + 0.4);\r\n      \r\n      // Enhanced Caustics (bright underwater light rays)\r\n      col += caustics * vec3(0.5, 0.9, 1.0) * 0.5;\r\n      \r\n      // Bright Sky Reflection\r\n      vec3 skyColor = vec3(0.6, 0.8, 0.95);\r\n      col = mix(col, skyColor, fresnel * 0.5);\r\n      \r\n      // Add Sun Highlight\r\n      col += SUN_COLOR * spec * 2.5;\r\n      \r\n      // Natural water interaction effects\r\n      float rippleIntensity = abs(ripple) * influence;\r\n      \r\n      // Refracted caustics (bright light bending through water)\r\n      float refractedCaustics = getCaustics(p * 2.0 + rippleIntensity * 0.5);\r\n      col += vec3(0.4, 0.7, 0.85) * refractedCaustics * rippleIntensity * 0.6;\r\n      \r\n      // Bright highlights on ripple peaks\r\n      float highlight = smoothstep(0.3, 0.8, ripple) * influence;\r\n      col += vec3(0.7, 0.9, 1.0) * highlight * 0.3;\r\n      \r\n      // Slight transparency effect where water is disturbed\r\n      col = mix(col, shallowColor, rippleIntensity * 0.15);\r\n\r\n      // 6. Post-Processing\r\n      // Brighten overall\r\n      col *= 1.3;\r\n      col = aces_tonemap(col);\r\n      \r\n      // Subtle vignette\r\n      col *= 1.0 - length(uv - 0.5) * 0.3;\r\n\r\n      gl_FragColor = vec4(col, 1.0);\r\n  }\r\n`;\r\n\r\n/**\r\n * COMPONENT\r\n */\r\n\r\nconst BackgroundShader = () => {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null);\r\n  const animationRef = useRef<number | null>(null);\r\n  const mouse = useSmoothMouse();\r\n  const mouseRef = useRef({ x: 0, y: 0, vx: 0, vy: 0, pressed: 0 });\r\n\r\n  // Sync React state to Ref for render loop access\r\n  useEffect(() => {\r\n    mouseRef.current = mouse;\r\n  }, [mouse]);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n    const gl = canvas.getContext('webgl');\r\n\r\n    if (!gl) return;\r\n\r\n    // --- Shader Boilerplate ---\r\n    const createShader = (gl: WebGLRenderingContext, type: number, source: string): WebGLShader | null => {\r\n      const shader = gl.createShader(type);\r\n      if (!shader) return null;\r\n      gl.shaderSource(shader, source);\r\n      gl.compileShader(shader);\r\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n        console.error(\"Shader Error:\", gl.getShaderInfoLog(shader));\r\n        gl.deleteShader(shader);\r\n        return null;\r\n      }\r\n      return shader;\r\n    };\r\n\r\n    const createProgram = (gl: WebGLRenderingContext, vs: WebGLShader, fs: WebGLShader): WebGLProgram | null => {\r\n      const program = gl.createProgram();\r\n      gl.attachShader(program, vs);\r\n      gl.attachShader(program, fs);\r\n      gl.linkProgram(program);\r\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n        console.error(\"Program Error:\", gl.getProgramInfoLog(program));\r\n        return null;\r\n      }\r\n      return program;\r\n    };\r\n\r\n    const vertShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\r\n    const fragShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\r\n    \r\n    if (!vertShader || !fragShader) return;\r\n    \r\n    const program = createProgram(gl, vertShader, fragShader);\r\n\r\n    if (!program) return;\r\n\r\n    // Create a full-screen triangle strip/quad\r\n    const positionBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n      -1, -1, 1, -1, -1, 1,\r\n      -1, 1, 1, -1, 1, 1,\r\n    ]), gl.STATIC_DRAW);\r\n\r\n    // Get Uniform Locations\r\n    const positionLoc = gl.getAttribLocation(program, 'position');\r\n    const timeLoc = gl.getUniformLocation(program, 'u_time');\r\n    const resLoc = gl.getUniformLocation(program, 'u_resolution');\r\n    const mouseLoc = gl.getUniformLocation(program, 'u_mouse');\r\n    const velocityLoc = gl.getUniformLocation(program, 'u_velocity');\r\n    const pressedLoc = gl.getUniformLocation(program, 'u_pressed');\r\n\r\n    let startTime = performance.now();\r\n\r\n    // Render Loop\r\n    const render = (now: number) => {\r\n      if (!canvas) return;\r\n\r\n      // Handle Window Resize\r\n      const displayWidth = window.innerWidth;\r\n      const displayHeight = window.innerHeight;\r\n      \r\n      if (canvas.width !== displayWidth || canvas.height !== displayHeight) {\r\n        canvas.width = displayWidth;\r\n        canvas.height = displayHeight;\r\n        gl.viewport(0, 0, canvas.width, canvas.height);\r\n      }\r\n\r\n      gl.useProgram(program);\r\n      gl.enableVertexAttribArray(positionLoc);\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n      gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);\r\n\r\n      // Pass Uniforms\r\n      gl.uniform1f(timeLoc, (now - startTime) * 0.001);\r\n      gl.uniform2f(resLoc, canvas.width, canvas.height);\r\n      // Invert Y for correct mouse tracking in GL coords\r\n      gl.uniform2f(mouseLoc, mouseRef.current.x, canvas.height - mouseRef.current.y);\r\n      gl.uniform2f(velocityLoc, mouseRef.current.vx, -mouseRef.current.vy);\r\n      gl.uniform1f(pressedLoc, mouseRef.current.pressed);\r\n      \r\n      gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n      animationRef.current = requestAnimationFrame(render);\r\n    };\r\n\r\n    animationRef.current = requestAnimationFrame(render);\r\n\r\n    // Cleanup\r\n    return () => {\r\n      if (animationRef.current) cancelAnimationFrame(animationRef.current);\r\n      if (gl) {\r\n        if (program) gl.deleteProgram(program);\r\n        if (vertShader) gl.deleteShader(vertShader);\r\n        if (fragShader) gl.deleteShader(fragShader);\r\n        if (positionBuffer) gl.deleteBuffer(positionBuffer);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <canvas \r\n      ref={canvasRef} \r\n      className=\"fixed top-0 left-0 w-full h-full block bg-black\"\r\n    />\r\n  );\r\n};\r\n\r\nexport default function App() {\r\n  return (\r\n    <div className=\"relative w-full h-screen bg-black overflow-hidden\">\r\n      <BackgroundShader />\r\n    </div>\r\n  );\r\n}",
      "type": "registry:ui",
      "target": "components/rareui/shaders/waterFlow.tsx"
    }
  ]
}